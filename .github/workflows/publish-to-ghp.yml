name: Publish Package with Dependencies to GitHub Packages

on:
  workflow_dispatch:
    inputs:
      package_name:
        description: 'NPM package name (e.g., "axios" or "@babel/core")'
        required: true
      package_version:
        description: 'Package version (e.g., "1.0.0")'
        required: true

env:
  # Use PAT_TOKEN if available, otherwise fall back to GITHUB_TOKEN
  # To create PAT: Settings -> Developer settings -> Personal access tokens -> Fine-grained tokens
  # Required permissions: read:packages, write:packages
  AUTH_TOKEN: ${{ secrets.PAT_TOKEN || secrets.GITHUB_TOKEN }}

jobs:
  publish:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write
      id-token: write
    
    steps:
      - uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '16.13.2'
          registry-url: 'https://npm.pkg.github.com'
          scope: '@${{ github.repository_owner }}'
          

      - name: Generate Complete Dependency Tree
        id: generate_tree
        run: |
          PKG_NAME="${{ github.event.inputs.package_name }}"
          VERSION="${{ github.event.inputs.package_version }}"
          
          echo "Generating complete dependency tree for $PKG_NAME@$VERSION..."
          
          # Install npm-remote-ls globally
          npm install -g npm-remote-ls
          
          # Generate flat dependency list
          echo "Running npm-remote-ls..."
          npm-remote-ls "$PKG_NAME@$VERSION" --development=false -f > deps_raw.txt || true
          
          # Parse and create dependency list
          cat > parse_deps.js << 'EOF'
          const fs = require('fs');

          const raw = fs.readFileSync('deps_raw.txt', 'utf8');
          const lines = raw.split('\n').map(l => l.trim()).filter(Boolean);
          
          const deps = [];
          const seen = new Set();
          
          for (let line of lines) {
            // Remove tree characters, brackets, and quotes
            line = line.replace(/[│├└─\[\],'"`]/g, '').trim();
          
            // Extract all patterns like package@version
            const matches = line.match(/(@?[^@\s]+\/?[^@\s]*)@([0-9]+\.[0-9]+\.[0-9]+[^\s]*)/g);
            if (!matches) continue;
          
            for (const match of matches) {
              const m = match.match(/^(@?[^@\s]+\/?[^@\s]*)@(.+)$/);
              if (!m) continue;
              const pkgName = m[1];
              const pkgVersion = m[2];
              const key = `${pkgName}@${pkgVersion}`;
              if (!seen.has(key)) {
                seen.add(key);
                deps.push({ name: pkgName, version: pkgVersion });
              }
            }
          }
          
          console.log(`Found ${deps.length} unique dependencies`);
          fs.writeFileSync('deps.json', JSON.stringify(deps, null, 2));
          EOF
          
          node parse_deps.js
          
          # Count dependencies
          DEP_COUNT=$(cat deps.json | jq '. | length')
          echo "dependency_count=$DEP_COUNT" >> $GITHUB_OUTPUT
          
          echo "Total dependencies to process: $DEP_COUNT"

      - name: Setup API Type
        id: setup_api
        run: |
          OWNER="${{ github.repository_owner }}"
          GITHUB_REPO="${{ github.repository }}"
          
          # Determine if org or user
          if [[ "$GITHUB_REPO" == *"/"* ]]; then
            REPO_OWNER=$(echo "$GITHUB_REPO" | cut -d'/' -f1)
            if [[ "$REPO_OWNER" != "$OWNER" ]]; then
              API_TYPE="orgs"
            else
              API_TYPE="users"
            fi
          else
            API_TYPE="users"
          fi
          
          echo "api_type=$API_TYPE" >> $GITHUB_OUTPUT
          echo "Using API type: $API_TYPE for owner: $OWNER"

      - name: Process & Publish Dependencies (Corrected)
        run: |
          cat > process_all.js << 'EOF'
          /**
           * PROCESS & PUBLISH PACKAGES CORRECTLY
           * -----------------------------------
           * FIXES INCLUDED:
           *  1. DO NOT flatten extracted directories (npm pack structure must remain)
           *  2. After rescoping package.json, run "npm install --production"
           *  3. Rescope dependencies to actual names, NOT alias format
           *  4. Re-pack using "npm pack" after installation
           *  5. Publish the newly created tarball
           */

          const fs = require('fs');
          const path = require('path');
          const { execSync } = require('child_process');

          const OWNER = process.env.OWNER.toLowerCase();
          const AUTH_TOKEN = process.env.AUTH_TOKEN;

          // FIX: Correct rescope function (NO alias format)
          function getPublishedName(orig) {
            if (orig.startsWith('@')) {
              const [scope, pkg] = orig.split('/');
              return `@${OWNER}/${scope.replace('@','')}-${pkg}`;
            }
            return `@${OWNER}/${orig}`;
          }

          // Load dep list
          const deps = JSON.parse(fs.readFileSync('deps.json', 'utf8'));
          console.log(`Processing ${deps.length} packages…`);

          function exec(cmd, opts = {}) {
            return execSync(cmd, { stdio: 'pipe', ...opts }).toString().trim();
          }

          for (let i = 0; i < deps.length; i++) {
            const { name, version } = deps[i];
            console.log(`\n[${i+1}/${deps.length}] ${name}@${version}`);

            // === DOWNLOAD ===
            const tarball = exec(`npm pack "${name}@${version}" --registry=https://registry.npmjs.org/`)
                            .split('\n').pop();
            if (!fs.existsSync(tarball)) {
              console.log("  ERROR: Tarball missing");
              continue;
            }

            // === EXTRACT – FIX: Keep npm pack structure exactly ===
            const workDir = `work-${i}`;
            exec(`mkdir -p ${workDir}`);
            exec(`tar -xzf "${tarball}" -C "${workDir}"`);

            // npm pack extracts into "package" folder
            const pkgDir = path.join(workDir, "package");
            if (!fs.existsSync(path.join(pkgDir, "package.json"))) {
              console.log("  ERROR: Invalid package structure");
              continue;
            }

            // === LOAD package.json ===
            const pkgPath = path.join(pkgDir, "package.json");
            const pkg = JSON.parse(fs.readFileSync(pkgPath, 'utf8'));

            // === RESCOPE NAME ===
            const newName = getPublishedName(name);
            pkg.name = newName;

            // === FIX 1: DO NOT alias dependencies inside libs ===
            // MUST use proper scoped dependency names
            function rescopeDeps(obj) {
              if (!obj) return obj;
              const out = {};
              for (const [dep, range] of Object.entries(obj)) {
                out[getPublishedName(dep)] = range;
              }
              return out;
            }

            pkg.dependencies = rescopeDeps(pkg.dependencies);
            pkg.devDependencies = rescopeDeps(pkg.devDependencies);
            pkg.peerDependencies = rescopeDeps(pkg.peerDependencies);
            pkg.optionalDependencies = rescopeDeps(pkg.optionalDependencies);

            // Persist updated package.json
            fs.writeFileSync(pkgPath, JSON.stringify(pkg, null, 2));

            // === FIX 2: INSTALL dependencies INSIDE the extracted package ===
            console.log("  Installing inside repackaged module…");
            exec(`npm install --production --ignore-scripts`, { cwd: pkgDir });

            // === FIX 3: REPACK the FINAL VALID PACKAGE ===
            console.log("  Repacking using npm pack…");
            const packed = exec(`npm pack`, { cwd: pkgDir }).split('\n').pop();
            const finalTar = path.join(pkgDir, packed);

            if (!fs.existsSync(finalTar)) {
              console.log("  ERROR: repacking failed");
              continue;
            }

            // === FIX 4: PUBLISH CLEAN TARBALL ===
            console.log(`  Publishing ${newName}@${version}`);
            try {
              exec(
                `npm publish "${finalTar}" --registry=https://npm.pkg.github.com --ignore-scripts`,
                {
                  cwd: pkgDir,
                  env: {
                    ...process.env,
                    NODE_AUTH_TOKEN: AUTH_TOKEN
                  }
                }
              );
              console.log("  ✓ Published successfully");
            } catch (err) {
              if (String(err).includes("cannot publish over") ||
                  String(err).includes("already exists")) {
                console.log("  ✓ Already published");
              } else {
                console.log("  ✗ Failed to publish");
                console.log(err.toString().split("\n")[0]);
              }
            }

            // Cleanup
            exec(`rm -rf ${workDir}`);
            fs.unlinkSync(tarball);
          }

          EOF

          node process_all.js
        env:
          OWNER: ${{ github.repository_owner }}
          AUTH_TOKEN: ${{ env.AUTH_TOKEN }}

      - name: Summary
        if: always()
        run: |
          echo "## Workflow Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Root Package:** ${{ github.event.inputs.package_name }}@${{ github.event.inputs.package_version }}" >> $GITHUB_STEP_SUMMARY
          echo "**Total Dependencies:** ${{ steps.generate_tree.outputs.dependency_count }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Results" >> $GITHUB_STEP_SUMMARY
          echo "- ✓ Already published: ${{ steps.publish_all.outputs.already_published }}" >> $GITHUB_STEP_SUMMARY
          echo "- ✓ Newly published: ${{ steps.publish_all.outputs.published }}" >> $GITHUB_STEP_SUMMARY
          echo "- ✗ Failed: ${{ steps.publish_all.outputs.failed }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          if [ "${{ steps.publish_all.outputs.failed }}" != "0" ] && [ -f "stats.json" ]; then
            echo "### Failed Packages" >> $GITHUB_STEP_SUMMARY
            echo '```' >> $GITHUB_STEP_SUMMARY
            cat stats.json | jq -r '.failedPackages[] | "\(.package)\n\(.error)\n"' >> $GITHUB_STEP_SUMMARY
            echo '```' >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "**Status:** ⚠️ Completed with failures" >> $GITHUB_STEP_SUMMARY
          else
            echo "**Status:** ✓ All packages processed successfully" >> $GITHUB_STEP_SUMMARY
          fi
