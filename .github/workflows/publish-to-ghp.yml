name: Publish to GitHub Packages with Caching

on:
  workflow_dispatch:
    inputs:
      package_name:
        description: 'NPM package name to mirror (e.g., "axios" or "@scope/pkg")'
        required: true
      package_version:
        description: 'Package version to mirror (e.g., "latest" or a specific version)'
        required: true
        default: 'latest'

jobs:
  publish:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write
    steps:
      - uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          registry-url: 'https://npm.pkg.github.com'
          scope: '@${{ github.repository_owner }}'

      - name: Sanitize Package Name
        id: sanitize_name
        run: |
          SANITIZED_NAME=$(echo "${{ github.event.inputs.package_name }}" | sed 's/@\([^@]*\)$//')
          echo "Original package name input: ${{ github.event.inputs.package_name }}, Version: ${{ github.event.inputs.package_version }}"
          echo "Sanitized package name: $SANITIZED_NAME"
          echo "sanitized_name=$SANITIZED_NAME" >> $GITHUB_OUTPUT

      - name: Resolve package version
        id: resolve_version
        run: |
          PACKAGE_NAME="${{ steps.sanitize_name.outputs.sanitized_name }}"
          VERSION_INPUT="${{ github.event.inputs.package_version }}"
          
          if [ "$VERSION_INPUT" = "latest" ]; then
            ACTUAL_VERSION=$(npm view "$PACKAGE_NAME" version --registry=https://registry.npmjs.org/)
            echo "Resolved 'latest' to version: $ACTUAL_VERSION"
          else
            # For exact versions, verify it exists
            if npm view "$PACKAGE_NAME@$VERSION_INPUT" version --registry=https://registry.npmjs.org/ > /dev/null 2>&1; then
              ACTUAL_VERSION="$VERSION_INPUT"
              echo "Using specified version: $ACTUAL_VERSION"
            else
              echo "Error: Version $VERSION_INPUT not found for package $PACKAGE_NAME"
              exit 1
            fi
          fi
          
          echo "resolved_version=$ACTUAL_VERSION" >> $GITHUB_OUTPUT
          echo "Final resolved version: $ACTUAL_VERSION"

      - name: Cache NPM Package and Dependencies
        id: cache_package
        uses: actions/cache@v4
        with:
          path: |
            ./cached-packages
            ./dependency-cache
          key: npm-package-with-deps-${{ steps.sanitize_name.outputs.sanitized_name }}-${{ steps.resolve_version.outputs.resolved_version }}
          restore-keys: |
            npm-package-with-deps-${{ steps.sanitize_name.outputs.sanitized_name }}-

      - name: Download Package and All Dependencies from NPM
        if: steps.cache_package.outputs.cache-hit != 'true'
        run: |
          echo "Cache miss - downloading package and all dependencies from NPM registry"
          mkdir -p cached-packages dependency-cache temp-workspace
          
          PACKAGE_NAME="${{ steps.sanitize_name.outputs.sanitized_name }}"
          PACKAGE_VERSION="${{ steps.resolve_version.outputs.resolved_version }}"
          
          cd temp-workspace
          cat > package.json << EOF
          {
            "name": "temp-installer",
            "version": "1.0.0",
            "dependencies": {
              "$PACKAGE_NAME": "$PACKAGE_VERSION"
            }
          }
          EOF
          
          echo "Installing $PACKAGE_NAME@$PACKAGE_VERSION and all dependencies..."
          npm install --registry=https://registry.npmjs.org/ --no-audit --no-fund
          
          mkdir -p ../dependency-cache
          echo "Generating dependency list..."
          npm list --json --all > ../dependency-cache/dependency-tree.json
          
          echo "Packing all dependencies..."
          WORKSPACE_ROOT=$(pwd)
          cd node_modules
          
          find . -name "package.json" -type f > ../dependency-cache/package-list.txt
          
          while IFS= read -r pkg_json; do
            pkg_dir=$(dirname "$pkg_json")
            original_dir=$(pwd)
            cd "$pkg_dir"
            
            pkg_name=$(node -p "require('./package.json').name" 2>/dev/null) || continue
            pkg_version=$(node -p "require('./package.json').version" 2>/dev/null) || continue
            
            if [ "$pkg_name" = "$PACKAGE_NAME" ]; then
              echo "Skipping main package: $pkg_name@$pkg_version (handled separately)"
              cd "$original_dir"
              continue
            fi
            
            echo "Processing dependency: $pkg_name@$pkg_version"
            safe_name=$(echo "$pkg_name" | sed 's/[@\/]/_/g')
            
            if npm pack --quiet 2>/dev/null; then
              tgz_file=$(ls *.tgz 2>/dev/null | head -1)
              if [ -n "$tgz_file" ]; then
                mv "$tgz_file" "${WORKSPACE_ROOT}/../dependency-cache/${safe_name}-${pkg_version}.tgz"
                echo "Cached: ${safe_name}-${pkg_version}.tgz"
              fi
            else
              echo "Failed to pack: $pkg_name@$pkg_version"
            fi
            
            cd "$original_dir"
          done < ../dependency-cache/package-list.txt
          
          # Handle the main package
          echo "Packing main package: $PACKAGE_NAME@$PACKAGE_VERSION"
          cd "${WORKSPACE_ROOT}/../cached-packages"
          npm pack "$PACKAGE_NAME@$PACKAGE_VERSION" --registry=https://registry.npmjs.org/
          
          echo "Package and all dependencies downloaded and cached"
          echo "Cached packages count: $(ls -1 ../dependency-cache/*.tgz 2>/dev/null | wc -l)"

      - name: Use Cached Package and Dependencies
        if: steps.cache_package.outputs.cache-hit == 'true'
        run: |
          echo "Cache hit - using cached package and dependencies"
          echo "Cached packages count: $(ls -1 dependency-cache/*.tgz 2>/dev/null | wc -l)"

      - name: Check if package already exists in GitHub Packages
        id: check_github_package
        run: |
          SCOPED_NAME="@${{ github.repository_owner }}/${{ steps.sanitize_name.outputs.sanitized_name }}"
          VERSION="${{ steps.resolve_version.outputs.resolved_version }}"
          
          if npm view "${SCOPED_NAME}@${VERSION}" version --registry=https://npm.pkg.github.com > /dev/null 2>&1; then
            echo "Package ${SCOPED_NAME}@${VERSION} already exists in GitHub Packages"
            echo "exists=true" >> $GITHUB_OUTPUT
          else
            echo "Package ${SCOPED_NAME}@${VERSION} not found in GitHub Packages"
            echo "exists=false" >> $GITHUB_OUTPUT
          fi
        env:
          NODE_AUTH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Publish Full Dependency Graph (Rescoped)
        run: |
          echo "Publishing full dependency graph with rescoped names..."

          MAIN_ORIG_NAME="${{ steps.sanitize_name.outputs.sanitized_name }}"
          MAIN_VERSION="${{ steps.resolve_version.outputs.resolved_version }}"

          if [ ! -d dependency-cache ]; then
            echo "No dependency-cache directory found."
            mkdir -p dependency-cache
          fi

          # Copy main package to dependency-cache for processing
          if ls cached-packages/*.tgz 1>/dev/null 2>&1; then
            cp cached-packages/*.tgz dependency-cache/ 2>/dev/null || true
            echo "Copied main package to dependency-cache"
          fi

          cd dependency-cache

          # Create publisher script
          cat > publish_graph.js << 'EOFJS'
          const fs = require('fs');
          const path = require('path');
          const { execSync } = require('child_process');

          const owner = process.env.GH_OWNER;
          if (!owner) { console.error('GH_OWNER env missing'); process.exit(1); }
          const token = process.env.NODE_AUTH_TOKEN || '';
          const registry = 'https://npm.pkg.github.com';
          
          const tgzFiles = fs.readdirSync('.').filter(f => f.endsWith('.tgz'));
          if (!tgzFiles.length) { 
            console.log('No tgz files found'); 
            process.exit(0); 
          }
          console.log('Found tarballs:', tgzFiles.length);

          const extractRoot = '.extract';
          if (!fs.existsSync(extractRoot)) fs.mkdirSync(extractRoot);

          // First pass: extract metadata & build name mapping
          const map = {}; // originalName -> scopedName
          const pkgMeta = {}; // originalName -> { version, dir }

          for (const file of tgzFiles) {
            const base = file.replace(/\.tgz$/, '');
            const outDir = path.join(extractRoot, base);
            if (!fs.existsSync(outDir)) fs.mkdirSync(outDir, { recursive: true });
            
            try {
              execSync(`tar -xzf "${file}" -C "${outDir}"`, { stdio: 'pipe' });
              const pkgPath = path.join(outDir, 'package', 'package.json');
              
              if (!fs.existsSync(pkgPath)) { 
                console.warn('Missing package.json in', file); 
                continue; 
              }
              
              const pkg = JSON.parse(fs.readFileSync(pkgPath, 'utf8'));
              const orig = pkg.name;
              const basePackageName = orig.split('/').pop();
              const scoped = `@${owner}/${basePackageName}`;
              
              map[orig] = scoped;
              pkgMeta[orig] = { 
                version: pkg.version, 
                dir: path.dirname(pkgPath),
                file: file
              };
              
              console.log(`Mapped: ${orig} -> ${scoped}@${pkg.version}`);
            } catch (e) {
              console.error('Failed to extract/read', file, ':', e.message);
            }
          }

          fs.writeFileSync('scoped-map.json', JSON.stringify(map, null, 2));
          console.log('Built mapping for', Object.keys(map).length, 'packages');

          // Helper to rewrite dependency object using map
          function rewriteDeps(obj) {
            if (!obj || typeof obj !== 'object') return obj;
            const out = {};
            for (const [name, range] of Object.entries(obj)) {
              out[map[name] || name] = range;
            }
            return out;
          }

          // Second pass: rewrite & publish
          let published = 0, skipped = 0, errors = 0;
          
          for (const [orig, meta] of Object.entries(pkgMeta)) {
            const pkgJsonPath = path.join(meta.dir, 'package.json');
            let pkg;
            
            try {
              pkg = JSON.parse(fs.readFileSync(pkgJsonPath, 'utf8'));
            } catch (e) {
              console.error('Failed to read package.json for', orig, ':', e.message);
              errors++;
              continue;
            }
            
            const newName = map[orig];
            
            // Update package name
            pkg.name = newName;
            pkg.publishConfig = { registry };

            // Rewrite dependency graphs
            pkg.dependencies = rewriteDeps(pkg.dependencies);
            pkg.devDependencies = rewriteDeps(pkg.devDependencies);
            pkg.peerDependencies = rewriteDeps(pkg.peerDependencies);
            pkg.optionalDependencies = rewriteDeps(pkg.optionalDependencies);

            // CRITICAL: Preserve important fields, only remove problematic scripts
            if (pkg.scripts) {
              const scriptsToRemove = ['preinstall', 'install', 'postinstall', 'prepublish', 'prepare'];
              scriptsToRemove.forEach(script => {
                if (pkg.scripts[script]) {
                  console.log(`Removing script '${script}' from ${pkg.name}`);
                  delete pkg.scripts[script];
                }
              });
            }

            // Ensure repository field exists
            if (!pkg.repository) {
              pkg.repository = { 
                type: 'git', 
                url: `git+https://github.com/${process.env.GITHUB_REPOSITORY}.git` 
              };
            }

            // Write back the modified package.json
            try {
              fs.writeFileSync(pkgJsonPath, JSON.stringify(pkg, null, 2));
            } catch (e) {
              console.error('Failed to write package.json for', orig, ':', e.message);
              errors++;
              continue;
            }

            // Check if package already exists
            const id = `${pkg.name}@${pkg.version}`;
            try {
              execSync(
                `npm view "${pkg.name}@${pkg.version}" version --registry=${registry}`, 
                { stdio: 'pipe', env: { ...process.env, NODE_AUTH_TOKEN: token } }
              );
              console.log('Already exists, skipping:', id);
              skipped++;
              continue;
            } catch { 
              // Package doesn't exist, proceed with publish
            }

            // Publish the package
            try {
              console.log('Publishing:', id);
              execSync(
                `npm publish --ignore-scripts --registry=${registry}`, 
                { 
                  cwd: meta.dir, 
                  stdio: 'inherit', 
                  env: { ...process.env, NODE_AUTH_TOKEN: token } 
                }
              );
              console.log('Successfully published:', id);
              published++;
            } catch (e) {
              console.error('Publish failed for', id);
              console.error('Command failed:', e.message);
              errors++;
            }
          }

          console.log('\n=== Summary ===');
          console.log('Published:', published);
          console.log('Skipped:', skipped);
          console.log('Errors:', errors);
          
          if (errors > 0 && published === 0) {
            process.exitCode = 1;
          }
          EOFJS

          GH_OWNER="${{ github.repository_owner }}" \
          GITHUB_REPOSITORY="${{ github.repository }}" \
          NODE_AUTH_TOKEN="${{ secrets.GITHUB_TOKEN }}" \
          node publish_graph.js
        env:
          NODE_AUTH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Log Package Skipped
        if: steps.check_github_package.outputs.exists == 'true'
        run: |
          echo "Main package already exists: @${{ github.repository_owner }}/${{ steps.sanitize_name.outputs.sanitized_name }}@${{ steps.resolve_version.outputs.resolved_version }}"
          echo "Dependencies will still be processed and published if they don't exist."

      - name: Log Cache Status
        run: |
          if [ "${{ steps.cache_package.outputs.cache-hit }}" = "true" ]; then
            echo "Used cached package and dependencies"
          else
            echo "Downloaded fresh package and dependencies and cached for future runs"
          fi
          
          if [ -d "dependency-cache" ]; then
            dep_count=$(ls -1 dependency-cache/*.tgz 2>/dev/null | wc -l)
            echo "Total dependency packages cached: $dep_count"
          fi