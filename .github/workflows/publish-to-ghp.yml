name: Publish Complete Dependency Tree to GitHub Packages

on:
  workflow_dispatch:
    inputs:
      package_name:
        description: 'NPM package name (e.g., "axios" or "@babel/core")'
        required: true
      package_version:
        description: 'Package version (e.g., "latest" or "1.0.0")'
        required: true
        default: 'latest'

jobs:
  publish:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write
    
    steps:
      - uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '16.13.2'
          registry-url: 'https://npm.pkg.github.com'
          scope: '@${{ github.repository_owner }}'

      - name: Resolve Package Version
        id: resolve
        run: |
          PKG_NAME="${{ github.event.inputs.package_name }}"
          PKG_VERSION="${{ github.event.inputs.package_version }}"
          
          if [ "$PKG_VERSION" = "latest" ]; then
            RESOLVED_VERSION=$(npm view "$PKG_NAME" version --registry=https://registry.npmjs.org/ 2>/dev/null || echo "")
            if [ -z "$RESOLVED_VERSION" ]; then
              echo "Error: Could not resolve version for $PKG_NAME"
              exit 1
            fi
          else
            RESOLVED_VERSION="$PKG_VERSION"
          fi
          
          # Create safe cache key
          SAFE_NAME=$(echo "$PKG_NAME" | sed 's/[@\/]/-/g; s/^-*//')
          CACHE_KEY="npm-deps-v4-${SAFE_NAME}-${RESOLVED_VERSION}"
          
          echo "package_name=$PKG_NAME" >> $GITHUB_OUTPUT
          echo "resolved_version=$RESOLVED_VERSION" >> $GITHUB_OUTPUT
          echo "cache_key=$CACHE_KEY" >> $GITHUB_OUTPUT
          
          echo "Package: $PKG_NAME@$RESOLVED_VERSION"
          echo "Cache Key: $CACHE_KEY"

      - name: Cache Dependencies
        id: cache
        uses: actions/cache@v4
        with:
          path: ./dependency-cache
          key: ${{ steps.resolve.outputs.cache_key }}
          restore-keys: npm-deps-v4-

      - name: Download Package and All Dependencies from NPM
        if: steps.cache_package.outputs.cache-hit != 'true'
        run: |
          echo "Cache miss - downloading package and all dependencies from NPM registry"
      
          mkdir -p cached-packages dependency-cache temp-workspace
          cd temp-workspace
          cat > package.json << EOF
          {
            "name": "temp-installer",
            "version": "1.0.0",
            "dependencies": {
              "${{ github.event.inputs.package_name }}": "${{ steps.resolve.outputs.resolved_version }}"
            }
          }
          EOF

          npm install -g npmignore
      
          echo "Installing ${{ github.event.inputs.package_name }}@${{ steps.resolve.outputs.resolved_version }} and all dependencies..."
          npm install --registry=https://registry.npmjs.org/ --no-audit --no-fund --ignore-scripts
      
          mkdir -p dependency-cache
          echo "Generating dependency list..."
          npm list --json --all > ../dependency-cache/dependency-tree.json
      
          echo "Packing all dependencies..."
          WORKSPACE_ROOT=$(pwd)
          cd node_modules
      
          # List all package.json files
          find . -name "package.json" -type f > ../dependency-cache/package-list.txt
      
          while IFS= read -r pkg_json; do
            pkg_dir=$(dirname "$pkg_json")
            original_dir=$(pwd)
            cd "$pkg_dir"
      
            # Get package info
            pkg_name=$(node -p "require('./package.json').name" 2>/dev/null) || continue
            pkg_version=$(node -p "require('./package.json').version" 2>/dev/null) || continue
      
            # Skip main package
            if [ "$pkg_name" = "${{ github.event.inputs.package_name }}" ]; then
              echo "Skipping main package: $pkg_name@$pkg_version (handled separately)"
              cd "$original_dir"
              continue
            fi
      
            echo "Processing dependency: $pkg_name@$pkg_version"
      
            safe_name=$(echo "$pkg_name" | sed 's/[@\/]/_/g')

            # Remove lifecycle scripts from package.json to prevent prepack from running
            node -e "
              const fs = require('fs');
              const pkg = JSON.parse(fs.readFileSync('package.json', 'utf8'));
              const scriptsToRemove = ['prepack', 'postpack', 'prepare', 'prepublish', 'prepublishOnly'];
              if (pkg.scripts) {
                scriptsToRemove.forEach(script => {
                  if (pkg.scripts[script]) {
                    delete pkg.scripts[script];
                  }
                });
              }
              fs.writeFileSync('package.json', JSON.stringify(pkg, null, 2));
            " 2>/dev/null || true
      
            # Pack dependency
            npm config set ignore-scripts true
            if npm pack --ignore-scripts --loglevel=error 2>/dev/null; then
              tgz_file=$(ls *.tgz 2>/dev/null | head -1)
              if [ -n "$tgz_file" ]; then
                mv "$tgz_file" "${WORKSPACE_ROOT}/../dependency-cache/${safe_name}-${pkg_version}.tgz"
                echo "Cached: ${safe_name}-${pkg_version}.tgz"
              fi
            else
              echo "Failed to pack: $pkg_name@$pkg_version"
            fi
      
            cd "$original_dir"
          done < ../dependency-cache/package-list.txt
      
          cd "${WORKSPACE_ROOT}/../cached-packages"
      
          echo "Packing main package..."
          TARBALL=$(npm pack ${{ github.event.inputs.package_name }}@${{ steps.resolve.outputs.resolved_version }} --registry=https://registry.npmjs.org/ --ignore-scripts)
      
          echo "Extracting tarball: $TARBALL, for package: ${{ steps.sanitize_name.outputs.sanitized_name }}"
      
          EXTRACT_DIR="extract-$(date +%s)"
          mkdir "$EXTRACT_DIR"
      
          # Extract tarball
          tar -xzf "$TARBALL" -C "$EXTRACT_DIR"
      
          # Detect extracted folder
          PKG_DIR=$(find "$EXTRACT_DIR" -maxdepth 1 -mindepth 1 -type d | head -1)
          echo "Detected extracted package directory: $PKG_DIR"
          cd "$PKG_DIR"
      
          cp package.json package.json.backup
      
          node -e "
            const fs = require('fs');
            const pkg = JSON.parse(fs.readFileSync('package.json', 'utf8'));
            const originalName = pkg.name;
      
            pkg.name = '@${{ github.repository_owner }}/'.toLowerCase() +
                       '${{ steps.sanitize_name.outputs.sanitized_name }}'.toLowerCase();
      
            pkg.publishConfig = { registry: 'https://npm.pkg.github.com' };
      
            if (!pkg.repository) {
              pkg.repository = {
                type: 'git',
                url: 'git+https://github.com/${{ github.repository }}.git'
              };
            }
      
            if (pkg.scripts) {
              const scriptsToRemove = ['test', 'prepublishOnly', 'prepack', 'postpack', 'prepare'];
              scriptsToRemove.forEach(script => {
                if (pkg.scripts[script]) {
                  console.log('Removing script:', script);
                  delete pkg.scripts[script];
                }
              });
      
              Object.keys(pkg.scripts).forEach(scriptName => {
                if (scriptName.includes('test') || scriptName.includes('build')) {
                  console.log('Removing potentially problematic script:', scriptName);
                  delete pkg.scripts[scriptName];
                }
              });
            }
      
            fs.writeFileSync('package.json', JSON.stringify(pkg, null, 2));
            console.log('Updated package name from', originalName, 'to', pkg.name);
          "
          cd ../../
          echo "Package and all dependencies download"
        env:
          NODE_AUTH_TOKEN: ${{ secrets.PERSONAL_ACCESS_TOKEN }}
          GH_OWNER: ${{ github.repository_owner }}
          GITHUB_REPOSITORY: ${{ github.repository }}
          MAIN_PACKAGE: ${{ steps.resolve.outputs.package_name }}
          MAIN_VERSION: ${{ steps.resolve.outputs.resolved_version }}
          
      - name: Verify Cache
        run: |
          PKG_COUNT=$(ls -1 dependency-cache/*.tgz 2>/dev/null | wc -l)
          
          if [ "${{ steps.cache.outputs.cache-hit }}" = "true" ]; then
            echo "Using cached dependencies ($PKG_COUNT packages)"
          else
            echo "Fresh download complete ($PKG_COUNT packages)"
          fi
          
          if [ "$PKG_COUNT" -eq 0 ]; then
            echo "ERROR: No packages found in cache!"
            exit 1
          fi
          
          echo ""
          echo "Sample packages (first 10):"
          ls -1 dependency-cache/*.tgz 2>/dev/null | head -10 | sed 's|dependency-cache/||; s|-| @ |; s|\.tgz$||; s|_|/|g' | sed 's/^/  /'

      - name: Publish Complete Dependency Graph to GitHub Packages
        run: |          
          cd dependency-cache
          
          cat > publish-all.js << 'PUBLISHER_SCRIPT_EOF'
          const fs = require('fs');
          const path = require('path');
          const { execSync } = require('child_process');
          
          const OWNER = process.env.GH_OWNER.toLowerCase();
          const TOKEN = process.env.NODE_AUTH_TOKEN;
          const REGISTRY = 'https://npm.pkg.github.com';
          const MAIN_PKG = process.env.MAIN_PACKAGE;
          const MAIN_VER = process.env.MAIN_VERSION;
          
          console.log(`Owner: @${OWNER}`);
          console.log(`Main package: ${MAIN_PKG}@${MAIN_VER}\n`);
          
          const tgzFiles = fs.readdirSync('.').filter(f => f.endsWith('.tgz'));
          console.log(`Found ${tgzFiles.length} packages\n`);
          
          if (tgzFiles.length === 0) {
            console.error('ERROR: No packages found!');
            process.exit(1);
          }
          
          // Generate rescoped name
          function rescopeName(origName) {
            const lowerOwner = OWNER.toLowerCase();
            if (origName.startsWith('@')) {
              const [scope, pkg] = origName.split('/');
              return `@${lowerOwner}/${scope.substring(1)}-${pkg}`.toLowerCase();
            }
            return `@${lowerOwner}/${origName}`.toLowerCase();
          }
          
          // Check if package exists via GitHub API
          function packageExists(scopedName, version) {
            try {
              const [scope, pkg] = scopedName.split('/');
              const encodedPkg = encodeURIComponent(pkg);
              const apiUrl = `https://api.github.com/users/${OWNER}/packages/npm/${encodedPkg}/versions`;
              
              const result = execSync(
                `curl -sf -H "Authorization: Bearer ${TOKEN}" -H "Accept: application/vnd.github+json" "${apiUrl}"`,
                { encoding: 'utf8', timeout: 15000 }
              );
              
              const versions = JSON.parse(result);
              return Array.isArray(versions) && versions.some(v => v.name === version);
            } catch (e) {
              return false;
            }
          }
          
          const extractDir = '.extract';
          if (!fs.existsSync(extractDir)) fs.mkdirSync(extractDir);
          
          // Phase 1: Extract and build package map
          console.log('Phase 1: Building package map...');
          const packageMap = new Map(); // origName@version -> scopedName
          const toPublish = [];
          
          for (const file of tgzFiles) {
            const baseName = file.replace(/\.tgz$/, '');
            const outDir = path.join(extractDir, baseName);
            
            try {
              if (!fs.existsSync(outDir)) fs.mkdirSync(outDir, { recursive: true });
              
              execSync(`tar -xzf "${file}" -C "${outDir}"`, { stdio: 'pipe' });

                // Find the first folder in the .tgz
              const topDir = execSync(`tar -tf "${file}"`)
                .toString()
                .split('\n')
                .map(line => line.split('/')[0])
                .find(x => x && !x.includes('.')) || 'package';

              const pkgJsonPath = path.join(outDir, topDir, 'package.json');
              
              if (!fs.existsSync(pkgJsonPath)) {
                console.warn(`  Warning: No package.json in ${file}`);
                continue;
              }

              
              const pkg = JSON.parse(fs.readFileSync(pkgJsonPath, 'utf8'));
              const origName = pkg.name;
              const origVer = pkg.version;
              const scopedName = rescopeName(origName);
              const key = `${origName}@${origVer}`;
              
              packageMap.set(key, scopedName);
              
              // Check if already published
              if (packageExists(scopedName, origVer)) {
                console.log(`${scopedName}@${origVer} (already published)`);
              } else {
                toPublish.push({
                  origName,
                  origVer,
                  scopedName,
                  dir: path.dirname(pkgJsonPath),
                  file
                });
                console.log(`${origName}@${origVer} → ${scopedName}`);
              }
            } catch (e) {
              console.error(`Failed to process ${file}:`, e.message);
            }
          }
          
          console.log(`\nPackages to publish: ${toPublish.length}`);
          
          if (toPublish.length === 0) {
            console.log('\nAll packages already published!');
            process.exit(0);
          }
          
          // Phase 2: Rewrite dependencies and publish
          console.log('\nPhase 2: Rewriting dependencies and publishing...\n');
          
          function rewriteDeps(deps) {
            if (!deps || typeof deps !== 'object') return deps;
            
            const rewritten = {};
            for (const [name, range] of Object.entries(deps)) {
              // Find matching package in our map
              const mapKey = Array.from(packageMap.keys()).find(k => k.startsWith(`${name}@`));
              const newName = mapKey ? packageMap.get(mapKey) : rescopeName(name);
              rewritten[newName] = range;
            }
            return rewritten;
          }
          
          let published = 0;
          let errors = 0;
          
          for (const pkg of toPublish) {
            const pkgJsonPath = path.join(pkg.dir, 'package.json');
            const pkgData = JSON.parse(fs.readFileSync(pkgJsonPath, 'utf8'));
            
            // CRITICAL: Change package name to scoped version
            pkgData.name = pkg.scopedName;
            
            // Rewrite ALL dependency types
            pkgData.dependencies = rewriteDeps(pkgData.dependencies);
            pkgData.devDependencies = rewriteDeps(pkgData.devDependencies);
            pkgData.peerDependencies = rewriteDeps(pkgData.peerDependencies);
            pkgData.optionalDependencies = rewriteDeps(pkgData.optionalDependencies);
            
            // Also rewrite bundledDependencies if present
            if (Array.isArray(pkgData.bundledDependencies)) {
              pkgData.bundledDependencies = pkgData.bundledDependencies.map(name => {
                const mapKey = Array.from(packageMap.keys()).find(k => k.startsWith(`${name}@`));
                return mapKey ? packageMap.get(mapKey) : rescopeName(name);
              });
            }
            
            // Fix invalid main field
            if (pkgData.main !== undefined && typeof pkgData.main !== 'string') {
              if (Array.isArray(pkgData.main) && pkgData.main.length > 0) {
                pkgData.main = pkgData.main[0];
              } else {
                delete pkgData.main;
              }
            }
            
            // Remove private flag
            delete pkgData.private;
            
            // Set publishConfig
            pkgData.publishConfig = {
              registry: REGISTRY
            };
            
            // Clean scripts
            if (pkgData.scripts) {
              const toRemove = Object.keys(pkgData.scripts).filter(k => 
                /pre|post|install|prepare|test|build/i.test(k)
              );
              toRemove.forEach(k => delete pkgData.scripts[k]);
            }

            const npmIgnorePath = path.join(pkg.dir, '.npmignore');
            if (fs.existsSync(npmIgnorePath)) {
              fs.unlinkSync(npmIgnorePath);
            }
            
            if (pkgData.files) {
              delete pkgData.files;
            }
            
            // Add repository
            if (!pkgData.repository) {
              pkgData.repository = {
                type: 'git',
                url: `git+https://github.com/${process.env.GITHUB_REPOSITORY}.git`
              };
            }
            
            fs.writeFileSync(pkgJsonPath, JSON.stringify(pkgData, null, 2));
            
            // Fix #4 — Re-pack tarball after rewrite
            console.log(`Repacking tarball for ${pkg.scopedName}@${pkg.origVer} ...`);
            const newTgz = execSync(
              'npm pack --ignore-scripts',
              { cwd: pkg.dir, encoding: 'utf8' }
            ).trim();
            
            // Absolute path to new tarball
            const tarballPath = path.join(pkg.dir, newTgz);
            
            // Publish
            console.log(`Publishing: ${pkg.scopedName}@${pkg.origVer}`);
            
            try {
              try {
                const output = execSync(
                'npm publish --ignore-scripts --loglevel=verbose',
                {
                  cwd: pkg.dir,
                  encoding: 'utf8',
                  env: { 
                    ...process.env, 
                    NODE_AUTH_TOKEN: TOKEN,
                    npm_config_registry: REGISTRY
                  }
                }
              );
              if (!packageExists(pkg.scopedName, pkg.origVer)) {
                console.error(`NOT indexed by GitHub: ${pkg.scopedName}`)
              }

              console.log(output);
              console.log(`Published OK\n`);
            } catch (e) {
              console.log("\n PUBLISH ERROR DUMP\n");
              console.log(e.stdout?.toString() || '');
              console.log(e.stderr?.toString() || '');
              console.log("\n");
              throw e;
            }

              console.log(`Published\n`);
              published++;
            } catch (e) {
              const err = e.message || e.toString();
              if (err.includes('409') || err.includes('Cannot publish over existing')) {
                console.log(`Already exists\n`);
              } else {
                console.error(`Error: ${err.substring(0, 200)}\n`);
                errors++;
              }
            }
          }
          
          console.log('=== Summary ===');
          console.log(`Published: ${published}`);
          console.log(`Errors: ${errors}`);
          console.log(`Already existed: ${tgzFiles.length - toPublish.length}`);
          
          if (errors > 0) {
            console.log('\nSome packages failed to publish');
            process.exitCode = 1;
          } else {
            console.log('\nAll packages processed successfully');
          }
          PUBLISHER_SCRIPT_EOF
          
          node publish-all.js
        env:
          NODE_AUTH_TOKEN: ${{ secrets.PERSONAL_ACCESS_TOKEN }}
          GH_OWNER: ${{ github.repository_owner }}
          GITHUB_REPOSITORY: ${{ github.repository }}
          MAIN_PACKAGE: ${{ steps.resolve.outputs.package_name }}
          MAIN_VERSION: ${{ steps.resolve.outputs.resolved_version }}
