name: Publish Package with Dependencies to GitHub Packages

on:
  workflow_dispatch:
    inputs:
      package_name:
        description: 'NPM package name (e.g., "axios" or "@babel/core")'
        required: true
      package_version:
        description: 'Package version (e.g., "1.0.0")'
        required: true

jobs:
  publish:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write
    
    steps:
      - uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20.x'
          registry-url: 'https://npm.pkg.github.com'
          scope: '@${{ github.repository_owner }}'

      - name: Validate Inputs
        id: validate
        run: |
          PKG_NAME="${{ github.event.inputs.package_name }}"
          PKG_VERSION="${{ github.event.inputs.package_version }}"
          
          echo "Package: $PKG_NAME@$PKG_VERSION"
          
          # Validate version format
          if ! echo "$PKG_VERSION" | grep -qE '^[0-9]+\.[0-9]+\.[0-9]+(-[0-9A-Za-z\.-]+)?$'; then
            echo "Error: Invalid version format: $PKG_VERSION"
            exit 1
          fi
          
          echo "package_name=$PKG_NAME" >> $GITHUB_OUTPUT
          echo "package_version=$PKG_VERSION" >> $GITHUB_OUTPUT

      - name: Generate Complete Dependency Tree
        id: generate_tree
        run: |
          PKG_NAME="${{ steps.validate.outputs.package_name }}"
          VERSION="${{ steps.validate.outputs.package_version }}"
          
          echo "Generating complete dependency tree for $PKG_NAME@$VERSION..."
          
          # Install npm-remote-ls globally
          npm install -g npm-remote-ls
          
          # Generate flat dependency list
          echo "Running npm-remote-ls..."
          npm-remote-ls "$PKG_NAME@$VERSION" --development=false -f > deps_raw.txt || true
          
          # Parse and create dependency list
          cat > parse_deps.js << 'EOF'
          const fs = require('fs');
          
          const raw = fs.readFileSync('deps_raw.txt', 'utf8');
          const lines = raw.split('\n').filter(l => l.trim());
          
          const deps = [];
          const seen = new Set();
          
          for (const line of lines) {
            const cleaned = line.trim().replace(/["',]/g, '');
            
            if (!cleaned || !cleaned.includes('@')) continue;
            
            let pkgName, pkgVersion;
            
            // Handle scoped packages: @scope/package@version
            if (cleaned.match(/^(@[^/]+\/[^@]+)@(.+)$/)) {
              const match = cleaned.match(/^(@[^/]+\/[^@]+)@(.+)$/);
              pkgName = match[1];
              pkgVersion = match[2];
            }
            // Handle unscoped packages: package@version
            else if (cleaned.match(/^([^@]+)@(.+)$/)) {
              const match = cleaned.match(/^([^@]+)@(.+)$/);
              pkgName = match[1];
              pkgVersion = match[2];
            }
            else {
              continue;
            }
            
            const key = `${pkgName}@${pkgVersion}`;
            if (!seen.has(key)) {
              seen.add(key);
              deps.push({ name: pkgName, version: pkgVersion });
            }
          }
          
          console.log(`Found ${deps.length} unique dependencies`);
          fs.writeFileSync('deps.json', JSON.stringify(deps, null, 2));
          EOF
          
          node parse_deps.js
          
          # Count dependencies
          DEP_COUNT=$(cat deps.json | jq '. | length')
          echo "dependency_count=$DEP_COUNT" >> $GITHUB_OUTPUT
          
          echo "Total dependencies to process: $DEP_COUNT"

      - name: Build Published Package Registry
        id: build_registry
        run: |
          echo "Building registry of published packages..."
          
          OWNER="${{ github.repository_owner }}"
          GITHUB_REPO="${{ github.repository }}"
          
          # Determine if org or user
          if [[ "$GITHUB_REPO" == *"/"* ]]; then
            REPO_OWNER=$(echo "$GITHUB_REPO" | cut -d'/' -f1)
            if [[ "$REPO_OWNER" != "$OWNER" ]]; then
              API_TYPE="orgs"
            else
              API_TYPE="users"
            fi
          else
            API_TYPE="users"
          fi
          
          # Create registry file
          touch published_registry.txt
          
          # Fetch all published packages
          PAGE=1
          while [ $PAGE -lt 10 ]; do
            RESPONSE=$(curl -sf -H "Authorization: Bearer ${{ secrets.GITHUB_TOKEN }}" \
              -H "Accept: application/vnd.github+json" \
              "https://api.github.com/${API_TYPE}/${OWNER}/packages?package_type=npm&per_page=100&page=${PAGE}" 2>/dev/null || echo "[]")
            
            # Check if response is empty array
            if [ "$RESPONSE" = "[]" ]; then
              break
            fi
            
            # Extract package names and get versions
            echo "$RESPONSE" | jq -r '.[].name' | while read -r pkg_name; do
              # Get versions for this package
              VERSIONS=$(curl -sf -H "Authorization: Bearer ${{ secrets.GITHUB_TOKEN }}" \
                -H "Accept: application/vnd.github+json" \
                "https://api.github.com/${API_TYPE}/${OWNER}/packages/npm/${pkg_name}/versions" 2>/dev/null || echo "[]")
              
              echo "$VERSIONS" | jq -r '.[].name' | while read -r version; do
                echo "@${OWNER}/${pkg_name}@${version}" >> published_registry.txt
              done
            done
            
            PAGE=$((PAGE + 1))
          done
          
          # Count entries
          REGISTRY_SIZE=$(wc -l < published_registry.txt)
          echo "Registry built: $REGISTRY_SIZE package versions"
          echo "registry_size=$REGISTRY_SIZE" >> $GITHUB_OUTPUT
        env:
          NODE_AUTH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Process and Publish All Dependencies
        id: publish_all
        run: |
          OWNER="${{ github.repository_owner }}"
          
          # Check available disk space
          echo "Available disk space:"
          df -h .
          
          cat > process_all.js << 'EOF'
          const fs = require('fs');
          const { execSync } = require('child_process');
          
          const deps = JSON.parse(fs.readFileSync('deps.json', 'utf8'));
          const publishedRegistry = new Set(
            fs.readFileSync('published_registry.txt', 'utf8')
              .split('\n')
              .filter(Boolean)
              .map(line => line.trim())
          );
          
          const owner = process.env.OWNER.toLowerCase();
          
          function getSafeName(origName) {
            return origName.replace(/[@\/]/g, '-').replace(/^-+/, '');
          }
          
          function getPublishedName(origName) {
            if (origName.startsWith('@')) {
              const [scope, pkg] = origName.split('/');
              return `@${owner}/${scope.substring(1)}-${pkg}`.toLowerCase();
            }
            return `@${owner}/${origName}`.toLowerCase();
          }
          
          function isAlreadyPublished(name, version) {
            const publishedName = getPublishedName(name);
            const key = `${publishedName}@${version}`;
            return publishedRegistry.has(key);
          }
          
          const stats = {
            total: deps.length,
            alreadyPublished: 0,
            published: 0,
            failed: 0
          };
          
          const failedPackages = [];
          
          console.log(`\nProcessing ${deps.length} packages...`);
          
          // Create a base working directory
          const workDir = process.cwd();
          
          for (let i = 0; i < deps.length; i++) {
            const dep = deps[i];
            const { name, version } = dep;
            
            console.log(`\n[${i + 1}/${deps.length}] ${name}@${version}`);
            
            // Check if already published
            if (isAlreadyPublished(name, version)) {
              console.log('  ✓ Already published');
              stats.alreadyPublished++;
              continue;
            }
            
            const tempDir = `temp-${i}`;
            
            try {
              // Ensure we're in the base directory
              process.chdir(workDir);
              
              // Clean up any existing temp directory
              try {
                execSync(`rm -rf ${tempDir}`, { stdio: 'pipe' });
              } catch {}
              
              // Download package
              console.log('  Downloading...');
              execSync(`mkdir -p ${tempDir}`, { stdio: 'pipe' });
              process.chdir(tempDir);
              
              const tarball = execSync(
                `npm pack "${name}@${version}" --registry=https://registry.npmjs.org/`,
                { encoding: 'utf8' }
              ).trim().split('\n').pop();
              
              if (!fs.existsSync(tarball)) {
                throw new Error('Failed to download package');
              }
              
              // Extract
              execSync(`mkdir -p extracted && tar -xzf "${tarball}" -C extracted`, { stdio: 'pipe' });
              
              // Move contents from package subdirectory if it exists
              if (fs.existsSync('extracted/package')) {
                execSync('mv extracted/package/* extracted/package/.* extracted/ 2>/dev/null || true', { stdio: 'pipe' });
                execSync('rm -rf extracted/package', { stdio: 'pipe' });
              }
              
              process.chdir('extracted');
              
              // Rescope package
              const pkg = JSON.parse(fs.readFileSync('package.json', 'utf8'));
              const publishedName = getPublishedName(name);
              
              console.log(`  Rescoping to ${publishedName}...`);
              
              pkg.name = publishedName;
              
              // Rescope dependencies
              function rescopeDeps(deps) {
                if (!deps || typeof deps !== 'object') return deps;
                const rescoped = {};
                for (const [depName, range] of Object.entries(deps)) {
                  const newName = getPublishedName(depName);
                  rescoped[newName] = range;
                }
                return rescoped;
              }
              
              pkg.dependencies = rescopeDeps(pkg.dependencies);
              pkg.devDependencies = rescopeDeps(pkg.devDependencies);
              pkg.peerDependencies = rescopeDeps(pkg.peerDependencies);
              pkg.optionalDependencies = rescopeDeps(pkg.optionalDependencies);
              
              if (Array.isArray(pkg.bundledDependencies)) {
                pkg.bundledDependencies = pkg.bundledDependencies.map(d => getPublishedName(d));
              }
              
              // Fix invalid main field
              if (pkg.main !== undefined && typeof pkg.main !== 'string') {
                if (Array.isArray(pkg.main) && pkg.main.length > 0) {
                  pkg.main = pkg.main[0];
                } else {
                  delete pkg.main;
                }
              }
              
              delete pkg.private;
              
              pkg.publishConfig = {
                registry: 'https://npm.pkg.github.com'
              };
              
              // Remove lifecycle scripts
              if (pkg.scripts) {
                const lifecycleScripts = [
                  'preinstall', 'install', 'postinstall',
                  'prepack', 'postpack',
                  'prepare', 'prepublish', 'prepublishOnly', 'postpublish'
                ];
                lifecycleScripts.forEach(script => delete pkg.scripts[script]);
              }
              
              // Fix repository field - ensure it's an object
              if (pkg.repository && typeof pkg.repository === 'string') {
                // Clean and normalize the URL
                let url = pkg.repository;
                // Remove any existing git+ prefix to avoid duplication
                url = url.replace(/^git\+/, '');
                // Ensure it starts with git+
                url = `git+${url}`;
                
                pkg.repository = {
                  type: 'git',
                  url: url
                };
              } else if (!pkg.repository) {
                pkg.repository = {
                  type: 'git',
                  url: `git+https://github.com/${{ github.repository }}.git`
                };
              } else if (pkg.repository && typeof pkg.repository === 'object' && pkg.repository.url) {
                // Clean and ensure URL has git+ prefix
                let url = pkg.repository.url;
                // Remove any existing git+ prefix to avoid duplication
                url = url.replace(/^git\+/, '');
                // Ensure it starts with git+
                pkg.repository.url = `git+${url}`;
              }
              
              fs.writeFileSync('package.json', JSON.stringify(pkg, null, 2));
              
              // Publish
              console.log('  Publishing...');
              try {
                const publishOutput = execSync('npm publish --ignore-scripts 2>&1', { 
                  encoding: 'utf8',
                  env: { ...process.env, NODE_AUTH_TOKEN: process.env.GITHUB_TOKEN }
                });
                
                // Log any warnings but don't fail
                if (publishOutput.includes('npm warn')) {
                  console.log('Publish warnings (non-fatal):');
                  const warnings = publishOutput.split('\n').filter(l => l.includes('npm warn'));
                  warnings.forEach(w => console.log(`    ${w.trim()}`));
                }
                
                console.log('  ✓ Published successfully');
                stats.published++;
                
                // Add to registry for subsequent packages
                publishedRegistry.add(`${publishedName}@${version}`);
              } catch (publishError) {
                // Check if it's just warnings (exit code 0 but stderr has warnings)
                if (publishError.status === 0) {
                  console.log('  ✓ Published successfully (with warnings)');
                  stats.published++;
                  publishedRegistry.add(`${publishedName}@${version}`);
                } else {
                  throw publishError;
                }
              }
              
            } catch (error) {
              const errorMsg = error.message || error.stderr || error.stdout || 'Unknown error';
              console.log(`  ✗ Failed: ${errorMsg.split('\n')[0]}`);
              stats.failed++;
              failedPackages.push(`${name}@${version}: ${errorMsg.split('\n')[0]}`);
            } finally {
              // Cleanup and go back to root
              try {
                process.chdir(workDir);
              } catch {}
              
              try {
                execSync(`rm -rf ${tempDir}`, { stdio: 'pipe' });
              } catch {}
            }
          }
          
          // Summary
          console.log('\n=== SUMMARY ===');
          console.log(`Total: ${stats.total}`);
          console.log(`Already published: ${stats.alreadyPublished}`);
          console.log(`Newly published: ${stats.published}`);
          console.log(`Failed: ${stats.failed}`);
          
          if (failedPackages.length > 0) {
            console.log('\nFailed packages:');
            failedPackages.forEach(p => console.log(`  - ${p}`));
          }
          
          // Write stats for GitHub Actions
          fs.writeFileSync('stats.json', JSON.stringify({
            total: stats.total,
            alreadyPublished: stats.alreadyPublished,
            published: stats.published,
            failed: stats.failed,
            failedPackages: failedPackages
          }, null, 2));
          
          // Exit with error if any failed
          if (stats.failed > 0) {
            process.exit(1);
          }
          EOF
          
          node process_all.js
          
          echo ""
          echo "Checking final disk space:"
          df -h .
          
          # Extract stats
          ALREADY_PUBLISHED=$(cat stats.json | jq -r '.alreadyPublished')
          PUBLISHED=$(cat stats.json | jq -r '.published')
          FAILED=$(cat stats.json | jq -r '.failed')
          
          echo "already_published=$ALREADY_PUBLISHED" >> $GITHUB_OUTPUT
          echo "published=$PUBLISHED" >> $GITHUB_OUTPUT
          echo "failed=$FAILED" >> $GITHUB_OUTPUT
        env:
          OWNER: ${{ github.repository_owner }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          NODE_AUTH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Summary
        if: always()
        run: |
          echo "## Workflow Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Root Package:** ${{ steps.validate.outputs.package_name }}@${{ steps.validate.outputs.package_version }}" >> $GITHUB_STEP_SUMMARY
          echo "**Total Dependencies:** ${{ steps.generate_tree.outputs.dependency_count }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Results" >> $GITHUB_STEP_SUMMARY
          echo "- ✓ Already published: ${{ steps.publish_all.outputs.already_published }}" >> $GITHUB_STEP_SUMMARY
          echo "- ✓ Newly published: ${{ steps.publish_all.outputs.published }}" >> $GITHUB_STEP_SUMMARY
          echo "- ✗ Failed: ${{ steps.publish_all.outputs.failed }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          if [ "${{ steps.publish_all.outputs.failed }}" != "0" ] && [ -f "stats.json" ]; then
            echo "### Failed Packages" >> $GITHUB_STEP_SUMMARY
            echo '```' >> $GITHUB_STEP_SUMMARY
            cat stats.json | jq -r '.failedPackages[]' >> $GITHUB_STEP_SUMMARY
            echo '```' >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "**Status:** ⚠️ Completed with failures" >> $GITHUB_STEP_SUMMARY
          else
            echo "**Status:** ✓ All packages processed successfully" >> $GITHUB_STEP_SUMMARY
          fi
